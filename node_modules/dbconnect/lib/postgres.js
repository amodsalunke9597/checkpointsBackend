// Generated by CoffeeScript 1.7.1
(function() {
  var DBConnect, PostgresDriver, Schema, postgres, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  postgres = require('pg');

  DBConnect = require('./dbconnect');

  _ = require('underscore');

  Schema = require('./schema');

  PostgresDriver = (function(_super) {
    __extends(PostgresDriver, _super);

    function PostgresDriver() {
      return PostgresDriver.__super__.constructor.apply(this, arguments);
    }

    PostgresDriver.defaultOptions = {
      host: 'localhost',
      port: 5432,
      database: 'postgres'
    };

    PostgresDriver.prototype.connString = function() {
      var database, host, password, port, user, _ref;
      _ref = this.args, user = _ref.user, password = _ref.password, host = _ref.host, port = _ref.port, database = _ref.database;
      if (user && password) {
        return "postgres://" + user + ":" + password + "@" + host + ":" + port + "/" + database;
      } else {
        return "postgres://" + host + ":" + port + "/" + database;
      }
    };

    PostgresDriver.prototype.tableName = function(name) {
      var helper;
      helper = function(name) {
        var i, normalized, splitted, str;
        splitted = name.split(/([A-Z]+)/);
        i = 0;
        normalized = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = splitted.length; _i < _len; _i++) {
            str = splitted[_i];
            if (str.match(/[A-Z]+/)) {
              if (i++ === 0) {
                _results.push(str.toLowerCase());
              } else {
                _results.push("_" + str.toLowerCase());
              }
            } else {
              _results.push(str);
            }
          }
          return _results;
        })();
        return normalized.join('') + "_t";
      };
      if (typeof name === 'string') {
        return helper(name);
      } else {
        return helper(name.name);
      }
    };

    PostgresDriver.prototype.connect = function(cb) {
      return postgres.connect(this.connString(), (function(_this) {
        return function(err, client, done) {
          if (err) {
            return cb(err);
          } else {
            _this.inner = client;
            _this.done = done;
            return cb(null, _this);
          }
        };
      })(this));
    };

    PostgresDriver.prototype._query = function(stmt, args, cb) {
      var parsed;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      parsed = this.parseStmt(stmt, args);
      return this.inner.query(parsed.stmt, parsed.args, (function(_this) {
        return function(err, res) {
          if (err) {
            return cb(err);
          } else if (stmt.selectOne) {
            return cb(null, res.rows[0]);
          } else if (stmt.next) {
            return _this._query(stmt.next, {}, cb);
          } else {
            return cb(null, res.rows);
          }
        };
      })(this));
    };

    PostgresDriver.prototype.parseStmt = function(stmt, args) {
      var i, matched, normalized, normedArgs, s, splitted, _i, _len, _ref;
      if (stmt instanceof Object && stmt.stmt && stmt.args) {
        _ref = stmt, stmt = _ref.stmt, args = _ref.args;
      }
      splitted = stmt.split(/(\$[\w]+)/);
      i = 1;
      normalized = [];
      normedArgs = [];
      for (_i = 0, _len = splitted.length; _i < _len; _i++) {
        s = splitted[_i];
        matched = s.match(/^\$([\w]+)$/);
        if (matched) {
          if (!args.hasOwnProperty(matched[1])) {
            throw new Error("Postgresql.query:stmt_missing_key: " + s);
          }
          normedArgs.push(args[matched[1]]);
          normalized.push("$" + (i++));
        } else {
          normalized.push(s);
        }
      }
      return {
        stmt: normalized.join(''),
        args: normedArgs
      };
    };

    PostgresDriver.prototype.disconnect = function(cb) {
      var e;
      try {
        this.done();
        return cb(null);
      } catch (_error) {
        e = _error;
        return cb(e);
      }
    };

    PostgresDriver.prototype.beginTrans = function(cb) {
      return this._query('begin', {}, cb);
    };

    PostgresDriver.prototype.commit = function(cb) {
      return this._query('commit', {}, cb);
    };

    PostgresDriver.prototype.rollback = function(cb) {
      return this._query('rollback', {}, cb);
    };

    PostgresDriver.prototype.ensureInsertColumns = function(table, kv) {
      var col, _i, _len, _ref, _results;
      _ref = table.columns;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        if (kv.hasOwnProperty(col.name)) {
          continue;
        } else if (!col.optional) {
          throw new Error("Postgresql.ensureInsertColumns:missing_required_column: " + col.name);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PostgresDriver.prototype.valuesStmt = function(table, args, i) {
      var col, keys, newKey, stmt, vals, _i, _len, _ref;
      if (i == null) {
        i = 0;
      }
      keys = [];
      vals = {};
      _ref = table.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        if (args.hasOwnProperty(col.name)) {
          newKey = "" + col.name + i;
          keys.push("$" + newKey);
          vals[newKey] = args[col.name];
        }
      }
      stmt = "(" + keys.join(', ') + ")";
      return {
        stmt: stmt,
        values: vals
      };
    };

    PostgresDriver.prototype.generateInsert = function(table, args) {
      var arg, col, columnText, i, idQuery, phText, select, stmt, stmts, values;
      stmts = args instanceof Array ? stmts = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
          arg = args[i];
          _results.push(this.valuesStmt(table, arg, i));
        }
        return _results;
      }).call(this) : [this.valuesStmt(table, args, 0)];
      columnText = '(' + ((function() {
        var _i, _len, _ref, _results;
        _ref = table.columns;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          col = _ref[_i];
          _results.push(col.name);
        }
        return _results;
      })()).join(', ') + ')';
      phText = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = stmts.length; _i < _len; _i++) {
          stmt = stmts[_i];
          _results.push(stmt.stmt);
        }
        return _results;
      })()).join(', ');
      values = _.extend.apply({}, [{}].concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = stmts.length; _i < _len; _i++) {
          stmt = stmts[_i];
          _results.push(stmt.values);
        }
        return _results;
      })()));
      idQuery = args instanceof Array ? table.idQuery(table.transpose(args)) : table.idQuery(args);
      select = args instanceof Array ? this.generateSelect(table, idQuery) : this.generateSelectOne(table, idQuery);
      return {
        stmt: "insert into " + (this.tableName(table.name)) + " " + columnText + " values " + phText,
        args: values,
        next: select
      };
    };

    PostgresDriver.prototype.escapeVal = function(val) {
      var strHelper;
      strHelper = function(val) {
        return "'" + val.replace(/\'/g, "''") + "'";
      };
      if (typeof val === 'number') {
        return "" + val;
      } else if (typeof val === 'string') {
        return strHelper(val);
      } else {
        return strHelper(val.toString());
      }
    };

    PostgresDriver.prototype.criteriaQuery = function(table, query, sep) {
      var criteria, key, v, val;
      if (sep == null) {
        sep = ' and ';
      }
      criteria = [];
      for (key in query) {
        val = query[key];
        if (table.columns.hasOwnProperty(key)) {
          if (val instanceof Array) {
            criteria.push("" + key + " in (" + (((function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = val.length; _i < _len; _i++) {
                v = val[_i];
                _results.push(this.escapeVal(v));
              }
              return _results;
            }).call(this)).join(', ')) + ")");
          } else {
            criteria.push("" + key + " = $" + key);
          }
        }
      }
      return criteria.join(sep);
    };

    PostgresDriver.prototype.generateDelete = function(table, query) {
      var stmt;
      if (Object.keys(query).length === 0) {
        return {
          stmt: "delete from " + (this.tableName(table.name)),
          args: query
        };
      } else {
        stmt = this.criteriaQuery(table, query);
        return {
          stmt: "delete from " + (this.tableName(table.name)) + " where " + stmt,
          args: query
        };
      }
    };

    PostgresDriver.prototype.generateSelect = function(table, query) {
      var stmt;
      if (Object.keys(query).length === 0) {
        return {
          stmt: "select * from " + (this.tableName(table.name)),
          args: query
        };
      } else {
        stmt = this.criteriaQuery(table, query);
        return {
          stmt: "select * from " + (this.tableName(table.name)) + " where " + stmt,
          args: query
        };
      }
    };

    PostgresDriver.prototype.generateSelectOne = function(table, query) {
      var stmt;
      if (Object.keys(query).length === 0) {
        return {
          stmt: "select * from " + (this.tableName(table.name)),
          args: query,
          selectOne: true
        };
      } else {
        stmt = this.criteriaQuery(table, query);
        return {
          stmt: "select * from " + (this.tableName(table.name)) + " where " + stmt,
          args: query,
          selectOne: true
        };
      }
    };

    PostgresDriver.prototype.generateUpdate = function(table, setExp, query) {
      var queryGen, setGen;
      setGen = this.criteriaQuery(table, setExp, ', ');
      if (Object.keys(query).length === 0) {
        return {
          stmt: "update " + (this.tableName(table.name)) + " set " + setGen,
          args: setExp
        };
      } else {
        queryGen = this.criteriaQuery(table, query);
        return {
          stmt: "update " + (this.tableName(table.name)) + " set " + setGen + " where " + queryGen,
          args: _.extend({}, setExp, query)
        };
      }
    };

    PostgresDriver.prototype.normalizeRecord = function(table, rec) {
      var col, lc, obj, _i, _len, _ref;
      obj = {};
      _ref = table.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        lc = col.name.toLowerCase();
        if (rec.hasOwnProperty(col.name)) {
          obj[col.name] = rec[col.name];
        } else if (rec.hasOwnProperty(lc)) {
          obj[col.name] = rec[lc];
        } else {
          throw new Error("PostgresDriver.normalizeRecord:unknown_column: " + col.name);
        }
      }
      return obj;
    };

    PostgresDriver.prototype.prepareSpecial = function(key, val) {
      if (typeof val === 'string') {
        return this.prepare(key, function(args, cb) {
          return this.query(val, args, cb);
        });
      } else {
        throw new Error("PostgresDriver.prepareSpecial:unsupported_query_type: " + val);
      }
    };

    PostgresDriver.prototype.supports = function(key) {
      if (key === 'in') {
        return true;
      } else if (key === 'insertMulti') {
        return true;
      } else {
        return false;
      }
    };

    PostgresDriver.prototype.generateCreateTable = function(table) {
      var columns, indexes, specs;
      columns = this.generateColumns(table);
      indexes = this.generateEmbeddedIndexes(table);
      specs = ['  id serial not null primary key'].concat(columns, indexes).join('\n  , ');
      return "create table if not exists " + (this.tableName(table)) + " (\n" + specs + "\n  );";
    };

    PostgresDriver.prototype.generateDropTable = function(table) {
      return "drop table if exists " + (this.tableName(table)) + ";\n";
    };

    PostgresDriver.prototype.generateEmbeddedIndexes = function(table) {
      var helper, index, result, _i, _len, _ref;
      helper = function(index) {
        var col, result;
        result = [];
        if (index.primary) {
          result.push('primary');
        } else if (index.unique) {
          result.push('unique');
        } else {
          result.push('index');
        }
        result.push("(");
        result.push(((function() {
          var _i, _len, _ref, _results;
          _ref = index.columns;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            col = _ref[_i];
            _results.push(col);
          }
          return _results;
        })()).join(', '));
        result.push(")");
        return result.join('');
      };
      result = [];
      _ref = table.indexes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        index = _ref[_i];
        if (index.columns.length === 1) {
          continue;
        } else {
          result.push(helper(index));
        }
      }
      return result;
    };

    PostgresDriver.prototype.generateColumns = function(table, columns) {
      var col, _i, _len, _results;
      if (columns == null) {
        columns = table.columns;
      }
      _results = [];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        _results.push(this.generateColumn(table, col));
      }
      return _results;
    };

    PostgresDriver.prototype.generateColumn = function(table, column) {
      var index, result;
      result = [];
      result.push(column.name);
      result.push(this.generateType(column));
      if (column.optional) {
        result.push("null");
      } else {
        result.push("not null");
      }
      if (column["default"]) {
        result.push(this.generateDefault(column));
      }
      index = table.getColumnIndex(column);
      if (index) {
        if (index.unique) {
          result.push('unique');
        } else if (index.primary) {
          result.push('primary');
        }
      }
      return result.join(' ');
    };

    PostgresDriver.prototype.generateType = function(col) {
      var type;
      type = col.type;
      if (!type.postgres) {
        throw new Error("postgres.generateType:type_has_no_postgres_equiv: " + type.name);
      } else if (type.postgres instanceof Function) {
        return type.postgres();
      } else {
        return type.postgres;
      }
    };

    PostgresDriver.prototype.generateDefault = function(col) {
      var converter, def, v;
      def = col.def["default"];
      if (def instanceof Object) {
        if (this.functions.hasOwnProperty(def.proc)) {
          converter = this.functions[def.proc];
          if (converter instanceof Function) {
            return "default " + (converter(def.args));
          } else {
            return "default " + converter + "(" + (((function() {
              var _i, _len, _ref, _results;
              _ref = def.args || [];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                _results.push(this.escapeVal(v));
              }
              return _results;
            }).call(this)).join(', ')) + ")";
          }
        } else {
          return "";
        }
      } else {
        return "default " + (this.escapeVal(def));
      }
    };

    PostgresDriver.prototype.generateForeignKeys = function(index) {
      var columns, refColumns, refTable, table;
      table = this.tableName(index.table);
      columns = index.columns.join(', ');
      refTable = this.tableName(index.reference.table);
      refColumns = index.reference.columns.join(', ');
      return "alter " + table + " add foreign key (" + columns + ") references " + refTable + " (" + refColumns + ");";
    };

    PostgresDriver.prototype.generateCreateIndex = function(index) {
      var columns, primaryOrUnique, table;
      table = this.tableName(index.table);
      columns = index.columns.join(', ');
      primaryOrUnique = index.primary ? "primary" : index.unique ? "unique" : "";
      return "create " + primaryOrUnique + " index " + index.name + " on " + table + " (" + columns + ");";
    };

    PostgresDriver.prototype.generateDropIndex = function(index) {
      return "drop index if exists " + index.name + ";";
    };

    PostgresDriver.prototype.generateSchema = function(schema) {
      var index, scripts, table, _i, _j, _len, _len1, _ref, _ref1;
      if (schema == null) {
        schema = this.schema;
      }
      scripts = [];
      _ref = schema.tables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        table = _ref[_i];
        scripts.push(this.generateCreateTable(table));
      }
      _ref1 = schema.indexes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        index = _ref1[_j];
        if (index.reference) {
          scripts.push(this.generateForeignKeys(index));
        }
        if (!(index.unique || index.primary)) {
          scripts.push(this.generateCreateIndex(index));
        }
      }
      return scripts.join('\n');
    };

    PostgresDriver.prototype.functions = {
      now: 'now'
    };

    return PostgresDriver;

  })(DBConnect);

  DBConnect.register('postgres', PostgresDriver);

  module.exports = PostgresDriver;

}).call(this);
