// Generated by CoffeeScript 1.4.0
(function() {
  var DBConnect, MongoDBDriver, Schema, mongodb, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  mongodb = require('mongodb');

  DBConnect = require('./dbconnect');

  _ = require('underscore');

  Schema = require('./schema');

  MongoDBDriver = (function(_super) {

    __extends(MongoDBDriver, _super);

    function MongoDBDriver() {
      return MongoDBDriver.__super__.constructor.apply(this, arguments);
    }

    MongoDBDriver.defaultOptions = {
      host: '127.0.0.1',
      port: 27017,
      database: 'test'
    };

    MongoDBDriver.connections = {};

    MongoDBDriver.prototype.tableName = function(name) {
      return name.replace(/^[A-Z]+/, function(str) {
        return str.toLowerCase();
      });
    };

    MongoDBDriver.prototype.id = function() {
      var database, host, port, _ref;
      _ref = this.args, host = _ref.host, port = _ref.port, database = _ref.database;
      return "" + host + ":" + port + "/" + database;
    };

    MongoDBDriver.hasConn = function(id) {
      if (this.connections.hasOwnProperty(id)) {
        return this.connections[id];
      } else {
        return void 0;
      }
    };

    MongoDBDriver.setConn = function(id, conn) {
      return this.connections[id] = conn;
    };

    MongoDBDriver.prototype.connect = function(cb) {
      var conn;
      conn = this.constructor.hasConn(this.id());
      if (conn) {
        this.inner = conn;
        return cb(null, this);
      } else {
        return this.innerConnect(cb);
      }
    };

    MongoDBDriver.prototype.innerConnect = function(cb) {
      var conn, database, host, id, port, queries, server, _ref,
        _this = this;
      _ref = this.args, host = _ref.host, port = _ref.port, database = _ref.database, queries = _ref.queries;
      id = this.id();
      try {
        server = new mongodb.Server(host || '127.0.0.1', port || 27017);
        conn = new mongodb.Db(database || 'test', server);
        return conn.open(function(err, inner) {
          if (err) {
            conn.close();
            return cb(err);
          } else {
            _this.inner = inner;
            _this.constructor.setConn(id, inner);
            process.on('exit', function() {
              console.log('closing mongodb', id);
              console.log('done');
              return inner.close();
            });
            return cb(null, _this);
          }
        });
      } catch (e) {
        console.error('ERROR: MongoConnection.connect', e);
        return cb(e);
      }
    };

    MongoDBDriver.prototype.disconnect = function(cb) {
      return cb(null);
    };

    MongoDBDriver.prototype._query = function(stmt, args, cb) {
      var table;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      if (!(stmt instanceof Object)) {
        throw new Error("MongodBDriver.query_invalid_adhoc_query: " + stmt);
      }
      if (stmt.insert) {
        try {
          table = this.tableName(stmt.insert);
          return this.inner.collection(table).insert(stmt.args, {
            safe: true
          }, function(err, res) {
            if (err) {
              return cb(err);
            } else {
              return cb(null, (stmt.args instanceof Array ? res : res[0]));
            }
          });
        } catch (e) {
          return cb(e);
        }
      } else if (stmt.select) {
        try {
          table = this.tableName(stmt.select);
          if (stmt.query instanceof Object) {
            return this.inner.collection(table).find(stmt.query || {}).toArray(function(err, recs) {
              if (err) {
                return cb(err);
              } else {
                return cb(null, recs);
              }
            });
          } else {
            return this.inner.collection(table).find().toArray(function(err, recs) {
              if (err) {
                return cb(err);
              } else {
                return cb(null, recs);
              }
            });
          }
        } catch (e) {
          return cb(e);
        }
      } else if (stmt.selectOne) {
        console.log('MongoDBDriver.selectOne', stmt);
        try {
          table = this.tableName(stmt.selectOne);
          if (stmt.query instanceof Object) {
            return this.inner.collection(table).find(stmt.query || {}).toArray(function(err, recs) {
              var rec;
              if (err) {
                return cb(err);
              } else {
                rec = recs.length > 0 ? recs[0] : null;
                return cb(null, rec);
              }
            });
          } else {
            return this.inner.collection(table).find().toArray(function(err, recs) {
              var rec;
              if (err) {
                return cb(err);
              } else {
                rec = recs.length > 0 ? recs[0] : null;
                return cb(null, rec);
              }
            });
          }
        } catch (e) {
          return cb(e);
        }
      } else if (stmt.update) {
        try {
          table = this.tableName(stmt.update);
          return this.inner.collection(table).update(stmt.query || {}, {
            $set: stmt.$set
          }, {
            safe: true,
            multi: true
          }, function(err, res) {
            if (err) {
              return cb(err);
            } else {
              return cb(null, res);
            }
          });
        } catch (e) {
          return cb(e);
        }
      } else if (stmt["delete"]) {
        try {
          table = this.tableName(stmt["delete"]);
          return this.inner.collection(table).remove(stmt.query, {
            safe: true
          }, function(err, res) {
            if (err) {
              return cb(err);
            } else {
              return cb(null, res);
            }
          });
        } catch (e) {
          return cb(e);
        }
      } else if (stmt.save) {
        try {
          table = this.tableName(stmt.save);
          return this.inner.collection(table).save(stmt.args, {
            safe: true
          }, function(err, res) {
            if (err) {
              return cb(err);
            } else {
              return cb(null, res);
            }
          });
        } catch (e) {
          return cb(e);
        }
      } else {
        return cb(new Error("MongoDBDriver.query_unsupported_adhoc_query: " + stmt));
      }
    };

    MongoDBDriver.prototype.prepareSpecial = function(key, args) {
      if (_.find(['select', 'selectOne', 'delete', 'update', 'insert', 'save'], (function(key) {
        return args.hasOwnProperty(key);
      }))) {
        return this.prepare(key, this.prepareStmt(args));
      } else {
        throw new Error("MongoDBDriver.unknown_prepare_special_args: " + (JSON.stringify(args)));
      }
    };

    MongoDBDriver.prototype.prepareStmt = function(stmt) {
      return function(args, cb) {
        var normalized;
        try {
          normalized = this.mergeQuery(stmt, args);
          return this._query(normalized, cb);
        } catch (e) {
          return cb(e);
        }
      };
    };

    MongoDBDriver.prototype.mergeQuery = function(stmt, args) {
      var helper, verifyRequired;
      helper = function(obj, args) {
        var key, res, val;
        if (obj instanceof Object) {
          res = {};
          for (key in obj) {
            val = obj[key];
            if (obj.hasOwnProperty(key)) {
              if (val.match(/^:/)) {
                if (args.hasOwnProperty(val.substring(1))) {
                  res[key] = args[val.substring(1)];
                } else {
                  res[key] = helper(val, args);
                }
              }
            }
          }
          return res;
        } else {
          return obj;
        }
      };
      verifyRequired = function(args, required) {
        var item, _i, _len;
        if (required == null) {
          required = stmt.required;
        }
        helper = function(args) {
          var key, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = required.length; _i < _len; _i++) {
            key = required[_i];
            if (!args.hasOwnProperty(key)) {
              throw new Error("missing_required_attribute: " + key + " in " + (JSON.stringify(args)));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        if (args instanceof Array) {
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            item = args[_i];
            helper(item);
          }
        } else {
          helper(args);
        }
        return args;
      };
      if (stmt.insert) {
        return {
          insert: stmt.insert,
          args: verifyRequired(args, stmt.required)
        };
      } else if (stmt.select) {
        return {
          select: stmt.select,
          query: helper(stmt.query, args)
        };
      } else if (stmt.selectOne) {
        return {
          selectOne: stmt.selectOne,
          query: helper(stmt.query, args)
        };
      } else if (stmt["delete"]) {
        return {
          "delete": stmt["delete"],
          query: helper(stmt.query, args)
        };
      } else if (stmt.update) {
        return {
          update: stmt.update,
          $set: helper(stmt.$set, args),
          query: helper(stmt.query, args)
        };
      } else if (stmt.save) {
        return {
          save: stmt.save,
          args: args
        };
      } else {
        throw new Error("MongoDBDriver.mergeQuery_unsupported_stmt: " + (JSON.stringify(stmt)));
      }
    };

    MongoDBDriver.prototype.generateSelect = function(table, query) {
      var key, val;
      for (key in query) {
        val = query[key];
        if (!table.hasColumn(key)) {
          throw new Error("dbconnect.query:unknown_column: " + key);
        }
      }
      return {
        select: table.name,
        query: query
      };
    };

    MongoDBDriver.prototype.generateSelectOne = function(table, query) {
      var key, val;
      for (key in query) {
        val = query[key];
        if (!table.hasColumn(key)) {
          throw new Error("dbconnect.query:unknown_column: " + key);
        }
      }
      return {
        selectOne: table.name,
        query: query
      };
    };

    MongoDBDriver.prototype.generateInsert = function(table, rec) {
      var obj;
      obj = table.make(rec);
      return {
        insert: table.name,
        args: obj
      };
    };

    MongoDBDriver.prototype.generateUpdate = function(table, rec, query) {
      return {
        update: table.name,
        query: query,
        $set: rec
      };
    };

    MongoDBDriver.prototype.generateDelete = function(table, query) {
      return {
        "delete": table.name,
        query: query
      };
    };

    MongoDBDriver.prototype.supports = function(key) {
      if (key === 'in') {
        return true;
      } else if (key === 'insertMulti') {
        return true;
      } else if (key === 'deleteMulti') {
        return false;
      } else {
        return false;
      }
    };

    return MongoDBDriver;

  })(DBConnect);

  DBConnect.register('mongo', MongoDBDriver);

  module.exports = MongoDBDriver;

}).call(this);
