// Generated by CoffeeScript 1.4.0

/*
  generic database pool. use this to wrap around the regular non-pooled db.

  pool = new Pool(inner, 100)
*/


(function() {
  var DBConnect, DBPool, DBPoolProxy, EventEmitter,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  DBConnect = require('./dbconnect');

  EventEmitter = require('events').EventEmitter;

  DBPool = (function(_super) {

    __extends(DBPool, _super);

    function DBPool(inner, maxSize) {
      this.inner = inner;
      this.maxSize = maxSize != null ? maxSize : 20;
      this.onRelease = __bind(this.onRelease, this);

      if (!DBConnect.has(this.inner.name)) {
        DBConnect.setup(this.inner);
      }
      this.active = [];
      this.free = [];
      this.queue = [];
      this.on('release', this.onRelease);
    }

    DBPool.prototype.acquire = function(cb) {
      if (this.hasFree()) {
        return this.acquireFree(cb);
      } else if (this.poolNotFull()) {
        return this.acquireNew(cb);
      } else {
        return this.waitToAcquire(cb);
      }
    };

    DBPool.prototype.poolNotFull = function() {
      return (this.active.length + this.free.length) < this.maxSize;
    };

    DBPool.prototype.acquireNew = function(cb) {
      var conn,
        _this = this;
      conn = DBConnect.make(this.inner.name);
      this.active.push(conn);
      return conn.connect(function(err, res) {
        if (err) {
          _this.removeFromActive(conn);
          return cb(err);
        } else {
          return cb(null, conn);
        }
      });
    };

    DBPool.prototype.hasFree = function() {
      return this.free.length > 0;
    };

    DBPool.prototype.acquireFree = function(cb) {
      var conn;
      conn = this.free.shift();
      this.active.push(conn);
      return cb(null, conn);
    };

    DBPool.prototype.waitToAcquire = function(cb) {
      return this.queue.push(cb);
    };

    DBPool.prototype.removeFromActive = function(conn) {
      var index;
      index = this.active.indexOf(conn);
      if (index >= 0) {
        this.active.splice(index, 1);
      }
      return conn;
    };

    DBPool.prototype.release = function(conn) {
      this.removeFromActive(conn);
      this.free.push(conn);
      return this.emit('release');
    };

    DBPool.prototype.onRelease = function() {
      if (this.queue.length > 0) {
        return this.acquireFree(this.queue.shift());
      }
    };

    return DBPool;

  })(EventEmitter);

  DBPoolProxy = (function(_super) {

    __extends(DBPoolProxy, _super);

    DBPoolProxy.pools = {};

    DBPoolProxy.hasPool = function(name) {
      if (this.pools.hasOwnProperty(name)) {
        return this.pools[name];
      } else {
        return void 0;
      }
    };

    DBPoolProxy.makePool = function(name, inner, maxSize) {
      if (this.hasPool(name)) {
        throw new Error("DBPool.duplicate: " + name);
      }
      this.pools[name] = new DBPool(inner, maxSize);
      return this.pools[name];
    };

    function DBPoolProxy(args) {
      var inner, maxSize, name, _ref;
      this.args = args;
      _ref = this.args, name = _ref.name, inner = _ref.inner, maxSize = _ref.maxSize;
      this.pool = this.constructor.hasPool(name);
      if (!this.pool) {
        this.pool = this.makePool(name, inner, maxSize);
      }
    }

    DBPoolProxy.prototype.connect = function(cb) {
      var _this = this;
      return this.pool.acquire(function(err, res) {
        if (err) {
          return cb(err);
        } else {
          _this.inner = res;
          return cb(null, _this);
        }
      });
    };

    DBPoolProxy.prototype.query = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (_ref = this.inner).query.apply(_ref, args);
    };

    DBPoolProxy.prototype.disconnect = function(cb) {
      this.pool.release(this.inner);
      return cb(null, this);
    };

    return DBPoolProxy;

  })(DBConnect);

  DBConnect.register('pool', DBPoolProxy);

  module.exports = DBPoolProxy;

}).call(this);
