// Generated by CoffeeScript 1.4.0
(function() {
  var ActiveRecord, ActiveRecordSet, Column, Columns, DATETIME, EMAIL, EventEmitter, HEXSTRING, INTEGER, Index, NUMBER, OrderedMap, Reference, STRING, Schema, Table, Tables, UUID, async, b2h, crypto, h2b, i, toHex, uuid, validator, _, _i,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ = require('underscore');

  uuid = require('node-uuid');

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  validator = require('validator');

  crypto = require('crypto');

  Column = (function() {

    function Column(table, def) {
      var col, optional, schemaType, type, _ref;
      this.table = table;
      this.def = def;
      _ref = this.def, col = _ref.col, type = _ref.type, optional = _ref.optional;
      this.name = col;
      schemaType = this.table.schema.hasType(type);
      if (!schemaType) {
        throw new Error("unknown_type: " + (JSON.stringify(type)));
      }
      this.type = schemaType;
      this.optional = optional || false;
      if (this.def["default"]) {
        this["default"] = this.setupDefault(this.def["default"]);
      }
      if (this.def.update) {
        this.update = this.setupDefault(this.def.update);
      }
    }

    Column.prototype.setupDefault = function(spec) {
      var args, proc,
        _this = this;
      if (spec instanceof Object) {
        proc = this.table.schema.hasFunction(spec.proc);
        if (!proc) {
          throw new Error("unknown_default_function: " + spec.proc);
        }
        if (spec.args instanceof Array) {
          args = spec.args;
          return function(v) {
            return proc.apply(null, args);
          };
        } else {
          return function(v) {
            if (arguments.length > 0) {
              return proc.apply(null, arguments);
            } else {
              return proc();
            }
          };
        }
      } else {
        return function() {
          return spec;
        };
      }
    };

    Column.prototype.destroy = function() {
      delete this.table;
      delete this.type;
      return delete this["default"];
    };

    Column.prototype.serialize = function() {
      return this.def;
    };

    Column.prototype.validate = function(val) {
      if (val !== void 0 && val !== null) {
        return this.type.convertable(val);
      } else if (this.optional) {
        return true;
      } else {
        throw new Error("value_required: " + this.table.name + "." + this.name);
      }
    };

    Column.prototype.make = function(val) {
      if (val !== void 0 && val !== null) {
        return this.type.make(val);
      } else if (this["default"]) {
        return this["default"].apply(this.table.schema.conn, []);
      } else if (this.optional) {
        return null;
      } else {
        throw new Error("value_required: " + this.table.name + "." + this.name);
      }
    };

    return Column;

  })();

  OrderedMap = (function(_super) {

    __extends(OrderedMap, _super);

    function OrderedMap(ensure, items) {
      var item, _i, _j, _len, _len1;
      if (items == null) {
        items = [];
      }
      Object.defineProperty(this, 'ensure', {
        value: ensure,
        enumerable: false
      });
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        this.ensure(item);
      }
      for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
        item = items[_j];
        this.push(item);
        this[item.name] = item;
      }
    }

    OrderedMap.prototype.destroy = function() {
      var key, val, _results;
      _results = [];
      for (key in this) {
        val = this[key];
        if (val instanceof Index) {
          _results.push(val.destroy());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    OrderedMap.prototype.splice = function() {
      var col, index, inserted, item, removed, removedCols, _i, _j, _k, _len, _len1, _len2;
      index = arguments[0], removed = arguments[1], inserted = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = inserted.length; _i < _len; _i++) {
        item = inserted[_i];
        this.ensure(item);
      }
      removedCols = OrderedMap.__super__.splice.apply(this, [index, removed].concat(__slice.call(inserted)));
      for (_j = 0, _len1 = removedCols.length; _j < _len1; _j++) {
        col = removedCols[_j];
        delete this[col.name];
      }
      for (_k = 0, _len2 = inserted.length; _k < _len2; _k++) {
        col = inserted[_k];
        this[col.name] = col;
      }
      return removedCols;
    };

    OrderedMap.prototype.push = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [this.length, 0].concat(__slice.call(col)));
    };

    OrderedMap.prototype.pop = function() {
      var col, res;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      res = this.splice(this.length - 1, 1);
      return res[0];
    };

    OrderedMap.prototype.unshift = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [0, 0].concat(__slice.call(col)));
    };

    OrderedMap.prototype.shift = function() {
      var res;
      res = this.splice(0, 1);
      return res[0];
    };

    return OrderedMap;

  })(Array);

  Columns = (function(_super) {

    __extends(Columns, _super);

    function Columns(columns) {
      var col, _i, _j, _len, _len1;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        this.ensureColumn(col);
      }
      for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
        col = columns[_j];
        this.push(col);
        this[col.name] = col;
      }
    }

    Columns.prototype.destroy = function() {
      var key, val, _results;
      _results = [];
      for (key in this) {
        val = this[key];
        if (val instanceof Index) {
          _results.push(val.destroy());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Columns.prototype.ensureColumn = function(col) {
      if (!(col instanceof Column)) {
        throw new Error("columns.ctor:not_a_column: " + col);
      }
    };

    Columns.prototype.splice = function() {
      var col, index, inserted, removed, removedCols, _i, _j, _k, _len, _len1, _len2;
      index = arguments[0], removed = arguments[1], inserted = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      for (_i = 0, _len = inserted.length; _i < _len; _i++) {
        col = inserted[_i];
        this.ensureColumn(col);
      }
      removedCols = Columns.__super__.splice.apply(this, [index, removed].concat(__slice.call(inserted)));
      for (_j = 0, _len1 = removedCols.length; _j < _len1; _j++) {
        col = removedCols[_j];
        delete this[col.name];
      }
      for (_k = 0, _len2 = inserted.length; _k < _len2; _k++) {
        col = inserted[_k];
        this[col.name] = col;
      }
      return removedCols;
    };

    Columns.prototype.push = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [this.length, 0].concat(__slice.call(col)));
    };

    Columns.prototype.pop = function() {
      var col, res;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      res = this.splice(this.length - 1, 1);
      return res[0];
    };

    Columns.prototype.unshift = function() {
      var col;
      col = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.splice.apply(this, [0, 0].concat(__slice.call(col)));
    };

    Columns.prototype.shift = function() {
      var res;
      res = this.splice(0, 1);
      return res[0];
    };

    return Columns;

  })(Array);

  Reference = (function() {

    function Reference(schema, index, table, columns) {
      this.schema = schema;
      this.index = index;
      this.table = table;
      this.columns = columns;
    }

    return Reference;

  })();

  Index = (function() {

    function Index(table, args) {
      var index, name, primary, reference, unique;
      this.table = table;
      index = args.index, primary = args.primary, unique = args.unique, name = args.name, reference = args.reference;
      if (primary) {
        this.init(primary, name);
        this.ensurePrimary();
      } else if (unique) {
        this.init(unique, name);
        this.ensureUnique();
      } else {
        this.init(index, name);
      }
      if (reference) {
        this.ensureReference(reference);
      }
    }

    Index.prototype.destroy = function() {
      return delete this.table;
    };

    Index.prototype.init = function(columns, name) {
      var col, _i, _len;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!this.table.hasColumn(col)) {
          throw new Error("unknown_column_in_table: " + col + ", " + this.table.name);
        }
      }
      this.columns = columns;
      this.name = (!name ? this.makeName() : name);
      return this.table.schema.registerIndex(this);
    };

    Index.prototype.makeName = function() {
      var columnName;
      columnName = this.columns.join('_');
      return "" + this.table.name + "_" + columnName;
    };

    Index.prototype.ensurePrimary = function() {
      return this.table.setPrimary(this);
    };

    Index.prototype.ensureUnique = function() {
      return this.unique = true;
    };

    Index.prototype.ensureReference = function(reference) {
      var col, columns, refTable, table, _i, _len, _ref;
      this.reference = reference;
      _ref = this.reference, table = _ref.table, columns = _ref.columns;
      refTable = this.table.schema.hasTable(table);
      if (!refTable) {
        throw new Error("Unknown_reference_table: " + table);
      }
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!refTable.hasColumn(col)) {
          throw new Error("unknown_reference_column: " + table + "." + col);
        }
      }
      return this.table.schema.registerReference(this, refTable, columns);
    };

    Index.prototype.serialize = function() {
      var index;
      index = {
        table: this.table.name,
        name: this.name
      };
      if (this.reference) {
        index.reference = this.reference;
      }
      if (this.primary) {
        index.primary = this.columns;
      } else if (this.unique) {
        index.unique = this.columns;
      } else {
        index.index = this.columns;
      }
      return index;
    };

    Index.prototype.referenceQuery = function(keyvals) {
      var col, i, obj, _i, _len, _ref;
      if (!this.reference) {
        throw new Error("Index.referenceQuery:not_a_foreign_key: " + this.name);
      }
      obj = {};
      _ref = this.reference.columns;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        col = _ref[i];
        if (keyvals.hasOwnProperty(col)) {
          obj[this.columns[i]] = keyvals[col];
        }
      }
      return obj;
    };

    Index.prototype.reverseReferenceQuery = function(keyvals) {
      var col, i, obj, _i, _len, _ref;
      if (!this.reference) {
        throw new Error("Index.referenceQuery:not_a_foreign_key: " + this.name);
      }
      obj = {};
      _ref = this.columns;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        col = _ref[i];
        if (keyvals.hasOwnProperty(col)) {
          obj[this.reference.columns[i]] = keyvals[col];
        }
      }
      return obj;
    };

    return Index;

  })();

  Table = (function() {

    function Table(schema, name, defs, mixin, loaded) {
      this.schema = schema;
      this.name = name;
      this.defs = defs;
      this.mixin = mixin;
      this.loaded = loaded != null ? loaded : false;
      if (this.schema.hasTable(this.name)) {
        throw new Error("duplicate_table_in_schema: " + this.name + ", " + this.schema.name);
      }
      this.initColumns();
      this.initIndexes();
    }

    Table.prototype.destroy = function() {
      var index, key;
      delete this.schema;
      for (key in indexes) {
        index = indexes[key];
        index.destroy();
      }
      delete this.indexes;
      return this.columns.destroy();
    };

    Table.prototype.ensureColumnNames = function(columns) {
      var col, names, _i, _len, _results;
      names = {};
      _results = [];
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (names.hasOwnProperty(col.col)) {
          throw new Error("duplicate_column_in_table: " + col.col + ", " + this.table.name);
        } else if (names.hasOwnProperty(col.col.toLowerCase())) {
          throw new Error("duplicate_column_case_insensitive_in_table: " + col.col + ", " + this.table.name);
        } else {
          names[col.col] = col;
          _results.push(names[col.col.toLowerCase()] = col);
        }
      }
      return _results;
    };

    Table.prototype.extractColumns = function(defs) {
      return _.filter(defs, function(obj) {
        return obj.col || obj.column;
      });
    };

    Table.prototype.initColumns = function() {
      var col, columns;
      columns = this.extractColumns(this.defs);
      this.ensureColumnNames(columns);
      return this.columns = new OrderedMap((function(col) {
        return col instanceof Column;
      }), (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = columns.length; _i < _len; _i++) {
          col = columns[_i];
          _results.push(this.makeColumn(col));
        }
        return _results;
      }).call(this));
    };

    Table.prototype.makeColumn = function(col) {
      return new Column(this, col);
    };

    Table.prototype.extractIndexes = function(defs) {
      var helper;
      helper = function(def) {
        return def.index || def.primary || def.unique || def.reference;
      };
      return _.filter(defs, helper);
    };

    Table.prototype.initIndexes = function() {
      var def, helper,
        _this = this;
      helper = function(def) {
        var indexDef;
        indexDef = _this.normalizeIndexDef(def);
        return new Index(_this, indexDef);
      };
      return this.indexes = new OrderedMap((function(idx) {
        return idx instanceof Index;
      }), (function() {
        var _i, _len, _ref, _results;
        _ref = this.extractIndexes(this.defs);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          def = _ref[_i];
          _results.push(helper(def));
        }
        return _results;
      }).call(this));
    };

    Table.prototype.normalizeIndexDef = function(def) {
      var col;
      if (def.col) {
        col = def.primary ? {
          primary: [def.col]
        } : def.unique ? {
          unique: [def.col]
        } : {
          index: [def.col]
        };
        if (def.reference) {
          col.reference = def.reference;
        }
        if (def.name) {
          col.name = def.name;
        }
        return col;
      } else {
        return def;
      }
    };

    Table.prototype.hasColumn = function(col) {
      if (this.columns.hasOwnProperty(col)) {
        return this.columns[col];
      } else {
        return void 0;
      }
    };

    Table.prototype.hasPrimary = function() {
      return this.primary;
    };

    Table.prototype.setPrimary = function(index) {
      if (this.primary) {
        throw new Error("Table_cannot_have_multiple_primary_keys");
      }
      index.primary = true;
      return this.primary = index;
    };

    Table.prototype.hasUnique = function() {
      var index, key, _ref;
      _ref = this.indexes;
      for (key in _ref) {
        index = _ref[key];
        if (index.unique) {
          return index;
        }
      }
      return void 0;
    };

    Table.prototype.hasPrimaryOrUnique = function() {
      if (this.hasPrimary()) {
        return this.primary;
      } else {
        return this.hasUnique();
      }
    };

    Table.prototype.references = function(table) {
      var index, key, _ref, _ref1;
      _ref = this.indexes;
      for (key in _ref) {
        index = _ref[key];
        if (((_ref1 = index.reference) != null ? _ref1.table : void 0) === table.name) {
          return index;
        }
      }
      return void 0;
    };

    Table.prototype.serialize = function() {
      var col, _i, _len, _ref, _results;
      _ref = this.columns;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        _results.push(col.serialize());
      }
      return _results;
    };

    Table.prototype.validate = function(val) {
      var col, _i, _len, _ref, _results;
      _ref = this.columns;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        _results.push(col.validate(val[col.name]));
      }
      return _results;
    };

    Table.prototype.make = function(val) {
      var col, obj, type, _i, _len, _ref;
      obj = {};
      _ref = this.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        obj[col.name] = col.make(val[col.name]);
      }
      type = this.schema.hasType(this.name);
      if (type) {
        return type.make(obj);
      } else {
        return obj;
      }
    };

    Table.prototype.idQuery = function(query) {
      var index;
      index = this.hasPrimaryOrUnique();
      if (index) {
        return this._idQuery(index, query);
      } else {
        return query;
      }
    };

    Table.prototype._idQuery = function(index, query) {
      var col, obj, _i, _len, _ref;
      obj = {};
      _ref = index.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        obj[col] = query[col];
      }
      return obj;
    };

    Table.prototype.getRelationQuery = function(tableName, args, record) {
      var index, query, table;
      table = this.schema.hasTable(tableName);
      if (!table) {
        throw new Error("ActiveRecord.select:unknown_table: " + tableName);
      }
      index = table.references(this);
      if (index) {
        query = index.referenceQuery(record);
        return _.extend(query, args);
      } else {
        index = this.references(table);
        if (index) {
          query = index.reverseReferenceQuery(record);
          return _.extend(query, args);
        } else {
          throw new Error("ActiveRecord.select:tables_not_related: " + this.name + ", " + tableName);
        }
      }
    };

    Table.prototype.transpose = function(records) {
      var col, columns, helper, _i, _len, _ref;
      columns = {};
      helper = function(col) {
        var data, rec, _i, _len;
        data = [];
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          rec = records[_i];
          data.push(rec[col.name]);
        }
        return data;
      };
      _ref = this.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        col = _ref[_i];
        columns[col.name] = helper(col);
      }
      return columns;
    };

    Table.prototype.getColumnIndex = function(column) {
      var helper, index, _i, _len, _ref;
      helper = function(columns) {
        return columns[0] === (column instanceof Column ? column.name : column);
      };
      _ref = this.indexes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        index = _ref[_i];
        if (index.columns.length === 1 && helper(index.columns)) {
          return index;
        }
      }
      return void 0;
    };

    return Table;

  })();

  ActiveRecord = (function(_super) {

    __extends(ActiveRecord, _super);

    function ActiveRecord(table, db, record) {
      this.table = table;
      this.db = db;
      this.record = this.db.normalizeRecord(this.table, record);
      this.changed = false;
      this.deleted = false;
      this.updated = {};
      _.extend(this, this.table.mixin);
    }

    ActiveRecord.prototype.set = function(key, val) {
      var column, i, obj, _i, _len, _ref, _results;
      if (this.deleted) {
        throw new Error("ActiveRecord.set:record_already_deleted");
      }
      obj = arguments.length === 2 ? (obj = {}, obj[key] = val, obj) : key;
      for (key in obj) {
        val = obj[key];
        this._setOne(key, val);
      }
      _ref = this.table.columns;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        column = _ref[i];
        if (column.update && !obj.hasOwnProperty(column.name)) {
          _results.push(this._setOne(column.name, column.update(this.record[column.name])));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ActiveRecord.prototype._setOne = function(key, val) {
      var col;
      col = this.table.hasColumn(key);
      if (col && !col.validate(val)) {
        throw new Error("" + table.name + "." + col.name + ":fail_validation: " + val);
      }
      this.updated[key] = val;
      return this.changed = true;
    };

    ActiveRecord.prototype.get = function(key) {
      if (this.deleted) {
        throw new Error("ActiveRecord.get:record_already_deleted");
      }
      if (this.updated.hasOwnProperty(key)) {
        return this.updated[key];
      } else if (this.record.hasOwnProperty(key)) {
        return this.record[key];
      } else {
        return void 0;
      }
    };

    ActiveRecord.prototype.select = function(tableName, args, cb) {
      var query;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        query = this.table.getRelationQuery(tableName, args, this.record);
        return this.db.select(tableName, query, cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.selectOne = function(tableName, args, cb) {
      var query;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      try {
        query = this.table.getRelationQuery(tableName, args, this.record);
        return this.db.selectOne(tableName, query, cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.insert = function(tableName, args, cb) {
      var index, query, table;
      table = this.table.schema.hasTable(tableName);
      if (!table) {
        return cb(new Error("ActiveRecord.selectOne:unknown_table: " + tableName));
      }
      index = table.references(this.table);
      if (index) {
        query = index.referenceQuery(this.record);
        args = _.extend({}, args, query);
        return this.db.insert(tableName, args, cb);
      } else {
        return cb(new Error("ActiveRecord.insert:tables_not_related: " + this.table.name + ", " + tableName));
      }
    };

    ActiveRecord.prototype.idQuery = function() {
      if (this.deleted) {
        throw new Error("ActiveRecord.idQuery:record_already_deleted");
      }
      return this.table.idQuery(this.record);
    };

    ActiveRecord.prototype.update = function(keyVals, cb) {
      if (this.deleted) {
        return cb(new Error("ActiveRecord.update:record_already_deleted"));
      }
      try {
        this.set(keyVals);
        return this.save(cb);
      } catch (e) {
        return cb(e);
      }
    };

    ActiveRecord.prototype.save = function(cb) {
      var query,
        _this = this;
      if (this.deleted) {
        return cb(new Error("ActiveRecord.save:record_already_deleted"));
      }
      if (this.changed) {
        query = this.db.generateUpdate(this.table, this.updated, this.idQuery());
        return this.db.query(query, {}, function(err, res) {
          if (err) {
            return cb(err);
          } else {
            _.extend(_this.record, _this.updated);
            _this.updated = {};
            _this.changed = false;
            return cb(null, _this);
          }
        });
      } else {
        return cb(null, this);
      }
    };

    ActiveRecord.prototype["delete"] = function(cb) {
      var query,
        _this = this;
      if (this.deleted) {
        return cb(new Error("ActiveRecord.delete:record_already_deleted"));
      }
      query = this.db.generateDelete(this.table, this.idQuery());
      return this.db.query(query, {}, function(err, res) {
        if (err) {
          return cb(err);
        } else {
          _this.deleted = true;
          return cb(null);
        }
      });
    };

    return ActiveRecord;

  })(EventEmitter);

  ActiveRecordSet = (function() {

    function ActiveRecordSet(table, db, records) {
      var record;
      this.table = table;
      this.db = db;
      this.records = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          record = records[_i];
          _results.push(this.db.normalizeRecord(this.table, record));
        }
        return _results;
      }).call(this);
      this.length = this.records.length;
    }

    ActiveRecordSet.prototype.select = function(tableName, args, cb) {
      var helper, query, records, table,
        _this = this;
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      records = [];
      table = this.table.schema.hasTable(tableName);
      if (!table) {
        throw new Error("ActiveRecordSet.select:unknown_table: " + tableName);
      }
      helper = function(rec, next) {
        var active;
        active = new ActiveRecord(_this.table, _this.db, rec);
        return active.select(tableName(args, function(err, recs) {
          var _i, _len;
          if (err) {
            return next(err);
          } else {
            for (_i = 0, _len = recs.length; _i < _len; _i++) {
              rec = recs[_i];
              if (rec instanceof ActiveRecord) {
                records.push(rec.record);
              } else {
                records.push(rec);
              }
            }
            return next(null);
          }
        }));
      };
      if (this.db.supports('in')) {
        query = this.table.getRelationQuery(tableName, args, this.transpose());
        return this.select(tableName, query, function(err, records) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, new ActiveRecordSet(table, _this.db, records));
          }
        });
      } else {
        return async.forEach(this.records, helper, function(err) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, new ActiveRecordSet(table, _this.db, records));
          }
        });
      }
    };

    ActiveRecordSet.prototype.selectOne = function(tableName, args, cb) {
      var _this = this;
      return this.select(tableName, args, function(err, recordSet) {
        if (err) {
          return cb(err);
        } else if (recordSet.length > 1) {
          return cb(null, recordSet.first());
        } else {
          return cb(new Error("ActiveRecordSet.selectOne:record_not_found: " + tableName + ", " + (JSON.stringify(args))));
        }
      });
    };

    ActiveRecordSet.prototype["delete"] = function(cb) {
      var args, query;
      args = this.table.idQuery(this.transpose());
      query = this.db.generateDelete(this.table, args);
      return this.db.query(query, cb);
    };

    ActiveRecordSet.prototype.transpose = function() {
      return this.table.transpose(this.records);
    };

    ActiveRecordSet.prototype.first = function() {
      return new ActiveRecord(this.table, this.db, this.records[0]);
    };

    ActiveRecordSet.prototype.filter = function(args) {
      var filtered, helper, kvHelper, kvOne;
      kvOne = function(rec, key, val) {
        if (rec.hasOwnProperty(key)) {
          return rec[key] === val;
        }
        return false;
      };
      kvHelper = function(rec, key, val) {
        var res, v, _i, _len;
        if (val instanceof Array) {
          for (_i = 0, _len = val.length; _i < _len; _i++) {
            v = val[_i];
            res = kvOne(rec, key, v);
            if (res) {
              return true;
            }
          }
        } else {
          return kvOne(rec, key, val);
        }
      };
      helper = function(rec) {
        var key, res, result, val;
        result = true;
        for (key in args) {
          val = args[key];
          res = kvHelper(rec, key, val);
          if (!res) {
            return false;
          }
        }
        return result;
      };
      filtered = _.filter(this.records, helper);
      return new ActiveRecordSet(this.table, this.db, filtered);
    };

    ActiveRecordSet.prototype.append = function(recordset) {
      if (recordset.table !== this.table) {
        throw new Error("ActiveRecordSet.append:not_the_same_table: " + recordset.table.name + " != " + this.table.name);
      }
      return this.records = this.records.concat(recordset.records);
    };

    return ActiveRecordSet;

  })();

  Tables = (function(_super) {

    __extends(Tables, _super);

    function Tables() {
      return Tables.__super__.constructor.apply(this, arguments);
    }

    return Tables;

  })(Array);

  Schema = (function() {

    Schema.builtInTypes = {};

    Schema.builtInFunctions = {};

    Schema.Record = ActiveRecord;

    Schema.RecordSet = ActiveRecordSet;

    Schema.Table = Table;

    Schema.registerType = function(name, type) {
      if (this.builtInTypes.hasOwnProperty(name)) {
        throw new Error("built_type_duplicate: " + name);
      }
      return this.builtInTypes[name] = type;
    };

    Schema.registerFunction = function(name, proc) {
      if (this.builtInFunctions.hasOwnProperty(name)) {
        throw new Error("builtin_function_duplicate: " + name);
      }
      return this.builtInFunctions[name] = proc;
    };

    function Schema(schema) {
      this.types = {};
      this.tables = new OrderedMap((function(t) {
        return t instanceof Table;
      }));
      this.indexes = new OrderedMap((function(idx) {
        return idx instanceof Index;
      }));
      this.references = {};
      this.functions = {};
      if (schema) {
        this.initialize(schema);
      }
    }

    Schema.prototype.destroy = function() {
      var index, key, table, _ref, _ref1;
      _ref = this.indexes;
      for (key in _ref) {
        index = _ref[key];
        index.destroy();
      }
      delete this.indexes;
      _ref1 = this.tables;
      for (key in _ref1) {
        table = _ref1[key];
        table.destroy();
      }
      delete this.tables;
      return delete this.conn;
    };

    Schema.prototype.initialize = function(schema) {
      var def, indexes, key, tables, val, _i, _len, _results;
      this.name = schema.name, tables = schema.tables, indexes = schema.indexes;
      if (tables) {
        for (key in tables) {
          val = tables[key];
          this.defineTable(key, val);
        }
      }
      if (indexes) {
        _results = [];
        for (_i = 0, _len = indexes.length; _i < _len; _i++) {
          def = indexes[_i];
          _results.push(this.defineIndex(def));
        }
        return _results;
      }
    };

    Schema.prototype.defineTable = function(name, defs, mixin) {
      var table;
      if (mixin == null) {
        mixin = {};
      }
      table = new Table(this, name, defs, mixin);
      return this.tables.push(table);
    };

    Schema.prototype.defineIndex = function(def) {
      var table;
      if (!def.table) {
        throw new Error("index_requires_table: " + def);
      }
      table = this.hasTable(def.table);
      if (!table) {
        throw new Error("index_table_unknown: " + def.table);
      }
      return new Index(table, def);
    };

    Schema.prototype.registerFunction = function(name, proc) {
      if (this.functions.hasOwnProperty(name)) {
        throw new Error("function_duplicated: " + name);
      }
      return this.functions[name] = proc;
    };

    Schema.prototype.hasFunction = function(name) {
      if (this.functions.hasOwnProperty(name)) {
        return this.functions[name];
      } else if (this.constructor.builtInFunctions.hasOwnProperty(name)) {
        return this.constructor.builtInFunctions[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.registerType = function(name, type) {
      if (this.types.hasOwnProperty(name)) {
        throw new Error("duplicate_type: " + name);
      }
      return this.types[name] = type;
    };

    Schema.prototype.registerTableType = function(name, type) {
      if (!type.hasOwnProperty('spec')) {
        throw new Error("lack_of_table_spec: " + name);
      }
      if (!type.make) {
        type.make = function(obj) {
          return new type(obj);
        };
      }
      this.defineTable(name, type.spec);
      return this.registerType(name, type);
    };

    Schema.prototype.hasType = function(name) {
      var helper, key, type, val,
        _this = this;
      helper = function(name) {
        if (_this.types.hasOwnProperty(name)) {
          return _this.types[name];
        } else if (_this.constructor.builtInTypes.hasOwnProperty(name)) {
          return _this.constructor.builtInTypes[name];
        } else {
          return void 0;
        }
      };
      if (typeof name === 'string') {
        return helper(name);
      } else {
        for (key in name) {
          val = name[key];
          type = helper(key);
          if (type != null ? type.takeArgs : void 0) {
            return new type(val);
          }
        }
        return void 0;
      }
    };

    Schema.prototype.registerIndex = function(index) {
      if (this.indexes.hasOwnProperty(index.name)) {
        throw new Error("index_name_duplication: " + index.name);
      }
      return this.indexes.push(index);
    };

    Schema.prototype.registerReference = function(index, table, columns) {
      return this.references[index.name] = new Reference(this, index, table, columns);
    };

    Schema.prototype.hasTable = function(name) {
      if (this.tables.hasOwnProperty(name)) {
        return this.tables[name];
      } else {
        return void 0;
      }
    };

    Schema.prototype.makeRecord = function(db, tableName, arg) {
      var table;
      table = this.hasTable(tableName);
      if (!table) {
        throw new Error("Schema.makeRecord:invalid_table: " + tableName);
      }
      return new ActiveRecord(table, db, arg);
    };

    Schema.prototype.makeRecordSet = function(db, tableName, arg) {
      var table;
      table = this.hasTable(tableName);
      if (!table) {
        throw new Error("Schema.makeRecord:invalid_table: " + tableName);
      }
      return new ActiveRecordSet(table, db, arg);
    };

    Schema.prototype.serialize = function() {
      var index, indexes, table, tables, _i, _j, _len, _len1, _ref, _ref1;
      tables = [];
      _ref = this.tables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        table = _ref[_i];
        tables.push(table.serialize());
      }
      indexes = [];
      _ref1 = this.indexes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        index = _ref1[_j];
        indexes.push(index.serialize());
      }
      return {
        name: this.name,
        tables: tables,
        indexes: indexes
      };
    };

    Schema.prototype.generate = function(conn) {
      var key, result, table, _ref, _results;
      result = [];
      _ref = this.tables;
      _results = [];
      for (key in _ref) {
        table = _ref[key];
        _results.push(result.push(table.generate(conn)));
      }
      return _results;
    };

    return Schema;

  })();

  STRING = (function() {

    STRING.make = function(val) {
      if (typeof val === 'string') {
        return val;
      } else if (val instanceof Object) {
        return JSON.stringify(val);
      } else {
        return "" + val;
      }
    };

    STRING.convertable = function(val) {
      return typeof val === 'string';
    };

    STRING.postgres = 'text';

    STRING.takeArgs = true;

    function STRING(_arg) {
      var max;
      max = _arg.max;
      if (typeof max === 'number') {
        this.max = max;
      } else {
        throw new Error("string_type:unknown_argument_type: " + max);
      }
    }

    STRING.prototype.convertable = function(val) {
      return this.constructor.convertable(val) && val.length <= this.max;
    };

    STRING.prototype.make = function(val) {
      var str;
      str = this.constructor.make(val);
      if (val.length <= this.max) {
        return val;
      } else {
        throw new Error("string_type:val_exceed_size: " + val + ", " + this.size);
      }
    };

    STRING.prototype.postgres = function() {
      return "varchar(" + this.max + ")";
    };

    return STRING;

  })();

  Schema.registerType('string', STRING);

  UUID = (function() {

    function UUID() {}

    UUID.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        return uuid.v4();
      }
    };

    UUID.convertable = function(val) {
      return val.match(/^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$/);
    };

    UUID.postgres = 'uuid';

    return UUID;

  })();

  Schema.registerType('uuid', UUID);

  NUMBER = (function() {

    function NUMBER() {}

    NUMBER.convertable = function(val) {
      return typeof val === 'number' || (typeof val === 'string' && val.match(/^-?\d*\.?\d*$/));
    };

    NUMBER.make = function(val) {
      if (typeof val === 'number') {
        return val;
      } else {
        return parseInt(val);
      }
    };

    NUMBER.postgres = 'double precision';

    return NUMBER;

  })();

  Schema.registerType('number', NUMBER);

  INTEGER = (function() {

    function INTEGER() {}

    INTEGER.convertable = function(val) {
      return (typeof val === 'number' && Math.round(val) === val) || (typeof val === 'string' && val.match(/^-?\d*/));
    };

    INTEGER.make = function(val) {
      if (this.convertable(val)) {
        if (typeof val === 'string') {
          return parseInt(val);
        } else {
          return val;
        }
      } else {
        throw new Error("invalid_integer: " + val);
      }
    };

    INTEGER.postgres = 'bigint';

    return INTEGER;

  })();

  Schema.registerType('integer', INTEGER);

  EMAIL = (function() {

    function EMAIL() {}

    EMAIL.convertable = function(val) {
      return validator.isEmail(val);
    };

    EMAIL.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        throw new Error("invalid_email: " + val);
      }
    };

    EMAIL.postgres = 'varchar(255)';

    return EMAIL;

  })();

  Schema.registerType('email', EMAIL);

  HEXSTRING = (function() {

    HEXSTRING.convertable = function(val) {
      return validator.isHexadecimal(val);
    };

    HEXSTRING.make = function(val) {
      if (this.convertable(val)) {
        return val;
      } else {
        throw new Error("invalid_hexstring: " + val);
      }
    };

    HEXSTRING.postgres = 'text';

    HEXSTRING.takeArgs = true;

    function HEXSTRING(_arg) {
      var max;
      max = _arg.max;
      if (typeof max === 'number') {
        this.max = max;
      } else {
        throw new Error("hexstring:unknown_argument_type: " + max);
      }
    }

    HEXSTRING.prototype.convertable = function(val) {
      return this.constructor.convertable(val) && val.length <= this.max;
    };

    HEXSTRING.prototype.make = function(val) {
      var str;
      str = this.constructor.make(val);
      if (val.length <= this.max) {
        return val;
      } else {
        throw new Error("hexstring:val_exceed_size: " + val + ", " + this.size);
      }
    };

    HEXSTRING.prototype.postgres = function() {
      return "varchar(" + this.max + ")";
    };

    return HEXSTRING;

  })();

  Schema.registerType('hexString', HEXSTRING);

  DATETIME = (function() {

    function DATETIME() {}

    DATETIME.convertable = function(val) {
      return validator.isDate(val);
    };

    DATETIME.make = function(val) {
      if (this.convertable(val)) {
        return new Date(Date.parse(val));
      } else {
        throw new Error("invalid_datetime: " + val);
      }
    };

    DATETIME.postgres = 'timestamp with time zone';

    return DATETIME;

  })();

  Schema.registerType('datetime', DATETIME);

  b2h = [];

  h2b = {};

  for (i = _i = 0; _i < 256; i = _i += 1) {
    b2h[i] = (i ^ 0x100).toString(16).substring(1);
    h2b[b2h[i]] = i;
  }

  toHex = function(bytes) {
    var byte, _j, _len, _results;
    _results = [];
    for (_j = 0, _len = bytes.length; _j < _len; _j++) {
      byte = bytes[_j];
      _results.push(b2h[byte]);
    }
    return _results;
  };

  Schema.registerFunction('randomBytes', function(size) {
    if (size == null) {
      size = 32;
    }
    return toHex(crypto.randomBytes(size)).join('');
  });

  Schema.registerFunction('makeUUID', uuid.v4);

  Schema.registerFunction('now', function() {
    return new Date();
  });

  Schema.registerFunction('increment', function(i) {
    if (i == null) {
      i = 0;
    }
    return i + 1;
  });

  module.exports = Schema;

}).call(this);
